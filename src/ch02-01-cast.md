# キャスト
TSには型の型のようなものがあり、それを満たす型にしかできないような操作があります。
いくつか例を挙げます。

```ts
type F<T extends any[]> = T;
type X = F<A>;// Aはany[]のサブタイプでなければならない
type Y = B["x"]// Bは`{ x: any }`のサブタイプでなければならない
```

しかしこのような条件を満たしていることが分かっていてもコンパイラが推論出来ておらずエラーになることがあります。  
そのような時は以下のような`Cast`型を定義して使いましょう。  
これは`T`は`P`を継承している時は分かっている時に`Cast<T, P>`と書いて使います。  
`Cast<T, P, D>`と書くことでキャストに失敗した時のデフォルト値を設定することが出来ます(`D`を指定しなかった場合のデフォルト値は`P`です)

```ts
type Cast<T, P, D extends P = P> = T extends P ? T : D;
```

以下のような動作をします。

```ts
assertType<TypeEq<Cast<1, number, 2>, 1>>();
assertType<TypeEq<Cast<1, string>, string>>();
assertType<TypeEq<Cast<1, string, "a">, "a">>();
```

使用例です。  
以下のコードはエラーが発生します。

```ts
type F<T> = "x" extends keyof T ? T : { x: 1 };
type G<T> = F<T>["x"];
```

`F<T>`の結果は`x`というプロパティを持っている事が分かっているのにエラーが発生します。  
そこで`Cast`を使って以下のように書き直すことでエラーを回避出来ます。

```ts
type G<T> = Cast<F<T>, { x: any }>["x"];
```

今回は型レベルのキャストを紹介しました。  
`Cast`の定義自体は簡単なのですぐ理解出来たと思います。  
再帰関数を組み合わせると型推論が上手く行かないことが多く、よく使うので覚えておきましょう。